Quantitative Project for Aqualite Pvt Ltd. I built a risk-driven portfolio and trade optimisation framework for the quant firm Aqualite, focusing on downside protection and tail-risk control. Estimated Value at Risk (VaR) using Monte Carlo simulations and historical methods.

https://colab.research.google.com/drive/14xL4uZhAIU8BdraIxLOntUHNEkRCEFnj?usp=sharing

# -*- coding: utf-8 -*-
"""VaR and Tailrisk.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14xL4uZhAIU8BdraIxLOntUHNEkRCEFnj
"""

from google.colab import drive
drive.mount('/content/drive')

"""Readed the files from google drive"""

import pandas as pd
auto=pd.read_csv('/content/drive/MyDrive/Colab Notebooks/NIFTY_AUTO.csv')
fin=pd.read_csv('/content/drive/MyDrive/Colab Notebooks/NIFTY_FINANCIALSERVICES.csv')
it=pd.read_csv('/content/drive/MyDrive/Colab Notebooks/NIFTY_IT.csv')

"""calculated logreturns of all sectors

"""

import pandas as pd
import numpy as np
auto['log_return_auto']=np.log(auto['NIFTY AUTO']/auto['NIFTY AUTO'].shift(1))
fin['log_return_fin']=np.log(fin['NIFTY FIN SERVICE']/fin['NIFTY FIN SERVICE'].shift(1))
it['log_return_it']=np.log(it['NIFTY IT']/it['NIFTY IT'].shift(1))
auto.dropna(inplace=True)
fin.dropna(inplace=True)
it.dropna(inplace=True)
print(auto.head())
print(fin.head())
print(it.head())

"""HISTORICAL SIMULATION"""

import numpy as np
import pandas as pd

def compute_var_es_series(returns, window=250):
    VaR_95 = []
    VaR_99 = []
    ES_95  = []
    ES_99  = []

    for i in range(len(returns)):
        if i < window:
            VaR_95.append(np.nan)
            VaR_99.append(np.nan)
            ES_95.append(np.nan)
            ES_99.append(np.nan)
        else:
            past = returns.iloc[i-window:i]

            var95 = np.percentile(past, 5)
            var99 = np.percentile(past, 1)

            es95 = past[past <= var95].mean()
            es99 = past[past <= var99].mean()

            VaR_95.append(var95)
            VaR_99.append(var99)
            ES_95.append(es95)
            ES_99.append(es99)

    return (
        pd.Series(VaR_95, index=returns.index),
        pd.Series(VaR_99, index=returns.index),
        pd.Series(ES_95,  index=returns.index),
        pd.Series(ES_99,  index=returns.index)
    )

var_hist_95_auto, var_hist_99_auto, es_hist_95_auto, es_hist_99_auto = \
    compute_var_es_series(auto['log_return_auto'])

var_hist_95_fin, var_hist_99_fin, es_hist_95_fin, es_hist_99_fin = \
    compute_var_es_series(fin['log_return_fin'])

var_hist_95_it, var_hist_99_it, es_hist_95_it, es_hist_99_it = \
    compute_var_es_series(it['log_return_it'])

"""by parametric gaussian distribution"""

import numpy as np
import pandas as pd
from scipy.stats import norm

def rolling_parametric_var_es(returns, window=250, alpha=0.95):
    VaR = []
    ES  = []

    z = norm.ppf(1 - alpha)

    for i in range(len(returns)):
        if i < window:
            VaR.append(np.nan)
            ES.append(np.nan)
        else:
            past = returns.iloc[i-window:i]

            mu = past.mean()
            sigma = past.std()

            var = mu + sigma * z
            es  = mu - sigma * (norm.pdf(z) / (1 - alpha))

            VaR.append(var)
            ES.append(es)

    return (
        pd.Series(VaR, index=returns.index),
        pd.Series(ES,  index=returns.index)
    )

# AUTO
var_param_95_auto, es_param_95_auto = rolling_parametric_var_es(
    auto['log_return_auto'], alpha=0.95)

var_param_99_auto, es_param_99_auto = rolling_parametric_var_es(
    auto['log_return_auto'], alpha=0.99)

# IT
var_param_95_it, es_param_95_it = rolling_parametric_var_es(
    it['log_return_it'], alpha=0.95)

var_param_99_it, es_param_99_it = rolling_parametric_var_es(
    it['log_return_it'], alpha=0.99)

# FIN
var_param_95_fin, es_param_95_fin = rolling_parametric_var_es(
    fin['log_return_fin'], alpha=0.95)

var_param_99_fin, es_param_99_fin = rolling_parametric_var_es(
    fin['log_return_fin'], alpha=0.99)

"""Monte carlo method"""

!pip install arch tqdm --quiet

import numpy as np
import pandas as pd
from arch import arch_model
from scipy.stats import t, chi2
from tqdm import tqdm


# ---------------------------------------------------
# Rolling full refit Monte Carlo t-GARCH VaR & ES
# ---------------------------------------------------
def rolling_garch_mc_var_es(returns, window=250, sims=5000, alpha=0.95, dist='t', mean='Constant', progress=True):
    if not isinstance(returns, pd.Series):
        returns = pd.Series(returns)
    n = len(returns)
    # prepare output series (NaN for early days)
    var_series = pd.Series(index=returns.index, dtype=float)
    es_series  = pd.Series(index=returns.index, dtype=float)
    sigma_series = pd.Series(index=returns.index, dtype=float)
    nu_series = pd.Series(index=returns.index, dtype=float)
    # loop through forecast dates
    rng = range(window, n)
    if progress:
        rng = tqdm(rng, desc="Rolling GARCH MC")
    for i in rng:
        train = returns.iloc[i - window: i]   # last 'window' days
        # fit GARCH(1,1)
        try:
            model = arch_model(train, mean=mean, lags=1 if mean=='AR' else 0, vol='Garch', p=1, q=1, dist=dist)
            res = model.fit(disp='off')           # silent
        except Exception as e:
            # on rare fit errors, skip day
            print(f"fit error at index {returns.index[i]}: {e}")
            var_series.iloc[i] = np.nan
            es_series.iloc[i] = np.nan
            continue
        # forecast one-step ahead mean & variance
        forecast = res.forecast(horizon=1)
        try:
            mu = forecast.mean.values[-1, 0]
        except:
            # fallback to sample mean if forecast mean missing
            mu = train.mean()
        sigma_t1 = np.sqrt(forecast.variance.values[-1, 0])
        # simulate shocks
        if dist.lower() == 't':
            nu = float(res.params.get('nu', 8.0))
            eps = t.rvs(df=nu, size=sims)
            nu_series.iloc[i] = nu
        else:
            eps = np.random.normal(0, 1, sims)
            nu_series.iloc[i] = np.nan
        # simulated returns
        simulated = mu + sigma_t1 * eps
        # VaR & ES (left tail)
        var_i = np.percentile(simulated, (1 - alpha) * 100)
        tail = simulated[simulated <= var_i]
        es_i = tail.mean() if tail.size > 0 else np.nan
        var_series.iloc[i] = var_i
        es_series.iloc[i]  = es_i
        sigma_series.iloc[i] = sigma_t1
    return var_series, es_series, sigma_series, nu_series

# ---------------------------------------------------
# AUTO sector
# ---------------------------------------------------
var_mc_95_auto, es_mc_95_auto, sigma_mc_auto, nu_mc_auto = rolling_garch_mc_var_es(
    auto['log_return_auto'], window=250, sims=5000, alpha=0.95, dist='t', mean='Constant', progress=True
)

var_mc_99_auto, es_mc_99_auto, sigma_mc_auto_99, nu_mc_auto_99 = rolling_garch_mc_var_es(
    auto['log_return_auto'], window=250, sims=5000, alpha=0.99, dist='t', mean='Constant', progress=True
)

# ---------------------------------------------------
# IT sector
# ---------------------------------------------------
var_mc_95_it, es_mc_95_it, sigma_mc_it, nu_mc_it = rolling_garch_mc_var_es(
    it['log_return_it'], window=250, sims=5000, alpha=0.95, dist='t', mean='Constant', progress=True
)

var_mc_99_it, es_mc_99_it, sigma_mc_it_99, nu_mc_it_99 = rolling_garch_mc_var_es(
    it['log_return_it'], window=250, sims=5000, alpha=0.99, dist='t', mean='Constant', progress=True
)

# ---------------------------------------------------
# FIN sector
# ---------------------------------------------------
var_mc_95_fin, es_mc_95_fin, sigma_mc_fin, nu_mc_fin = rolling_garch_mc_var_es(
    fin['log_return_fin'], window=250, sims=5000, alpha=0.95, dist='t', mean='Constant', progress=True
)

import numpy as np
from scipy.stats import chi2

def kupiec_test(returns, var_series, alpha=0.95):
    violations = (returns < var_series).astype(int).to_numpy()
    N = len(violations)
    x = violations.sum()
    pi_hat = x / N
    epsilon = 1e-10  # avoid log(0)
    LR = -2 * (
        np.log(((1-alpha)**(N-x) * (alpha**x)) + epsilon) -
        np.log(((1-pi_hat)**(N-x) * (pi_hat**x)) + epsilon)
    )
    p_value = 1 - chi2.cdf(LR, df=1)
    return LR, p_value, x, N


def christoffersen_test(returns, var_series):
    violations = (returns < var_series).astype(int)
    N = len(violations)

    n00 = n01 = n10 = n11 = 0
    for i in range(1, N):
        if violations.iloc[i-1] == 0 and violations.iloc[i] == 0:
            n00 += 1
        elif violations.iloc[i-1] == 0 and violations.iloc[i] == 1:
            n01 += 1
        elif violations.iloc[i-1] == 1 and violations.iloc[i] == 0:
            n10 += 1
        elif violations.iloc[i-1] == 1 and violations.iloc[i] == 1:
            n11 += 1

    pi0 = n01 / (n00 + n01) if (n00 + n01) > 0 else 0
    pi1 = n11 / (n10 + n11) if (n10 + n11) > 0 else 0
    pi = (n01 + n11) / (n00 + n01 + n10 + n11) if (n00 + n01 + n10 + n11) > 0 else 0

    L0 = ((1-pi)**(n00+n10)) * (pi**(n01+n11)) if pi not in [0,1] else 1e-10
    L1 = ((1-pi0)**n00) * (pi0**n01) * ((1-pi1)**n10) * (pi1**n11)
    L1 = L1 if L1 != 0 else 1e-10

    LR = -2 * np.log(L0 / L1)
    p_value = 1 - chi2.cdf(LR, df=2)
    return LR, p_value

sectors = {
    'AUTO': auto['log_return_auto'],
    'IT': it['log_return_it'],
    'FIN': fin['log_return_fin']
}

alphas = [0.95, 0.99]

var_dict = {
    'Historical': {
        0.95: {'AUTO': var_hist_95_auto, 'IT': var_hist_95_it, 'FIN': var_hist_95_fin},
        0.99: {'AUTO': var_hist_99_auto, 'IT': var_hist_99_it, 'FIN': var_hist_99_fin},
    },
    'Parametric': {
        0.95: {'AUTO': var_param_95_auto, 'IT': var_param_95_it, 'FIN': var_param_95_fin},
        0.99: {'AUTO': var_param_99_auto, 'IT': var_param_99_it, 'FIN': var_param_99_fin},
    },
    'MonteCarlo': {
        0.95: {'AUTO': var_mc_95_auto, 'IT': var_mc_95_it, 'FIN': var_mc_95_fin},
        0.99: {'AUTO': var_mc_99_auto, 'IT': var_mc_99_it, 'FIN': var_mc_99_fin},
    }
}

import pandas as pd

results = []

for method, alpha_dict in var_dict.items():
    for alpha, sector_vars in alpha_dict.items():
        for sector, var_series in sector_vars.items():
            # Kupiec test
            LR_kup, p_kup, x, N = kupiec_test(sectors[sector], var_series, alpha=alpha)
            # Christoffersen test
            LR_cc, p_cc = christoffersen_test(sectors[sector], var_series)

            results.append({
                'Method': method,
                'Sector': sector,
                'Alpha': alpha,
                'Kupiec_LR': LR_kup,
                'Kupiec_pval': p_kup,
                'Violations': f"{x}/{N}",
                'Christoffersen_LR': LR_cc,
                'Christoffersen_pval': p_cc
            })

results_df = pd.DataFrame(results)
print(results_df)
